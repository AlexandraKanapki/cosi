import nextFeatureByDistance from "./precompiler.nextFeatureByDistance.js";
import isObject from "../../../src/utils/isObject.js";


/**
 * Returns the closest features grouped by attribute value hidden in strings.
 * @param {Number[]} coordinate The coordinate to measure the distance for.
 * @param {ol/Feature[]} features A list of features to go through.
 * @param {String} knowledgeBaseKey The property name for the distance.
 * @param {String} propertyNameToGroupBy The property name to get the identifieres for the groups from.
 * @param {String} delimitor The delimitor, entities are separated with.
 * @param {String[]} propertyName All property names to included into the result.
 * @param {Function} onsuccess A function(concatAttributes) with concatAttributes to use outside of this file.
 * @param {Function} onerror A function(error) with error as instanceof Error to call in case of an error.
 * @returns {void}
 */
function nextGroupedFeaturesByDistance (coordinate, features, knowledgeBaseKey, propertyNameToGroupBy, delimitor, propertyName, onsuccess, onerror) {
    if (!Array.isArray(coordinate)) {
        onerror(new Error("nextGroupedFeaturesByDistance: coordinate is missing for the request"));
        return;
    }
    else if (!Array.isArray(features)) {
        onerror(new Error("nextGroupedFeaturesByDistance: features are missing for the request"));
        return;
    }
    const groupedFeatures = groupFeaturesByPropertyName(features, propertyNameToGroupBy, delimitor);

    getGroupedAttributes(coordinate, groupedFeatures, knowledgeBaseKey, propertyName, groupedAttributes => {
        const pureGroupedAttributes = purifyGroupedAttributes(groupedAttributes, propertyNameToGroupBy, delimitor, knowledgeBaseKey),
            concatAttributes = concatGroupAttributes(pureGroupedAttributes);

        onsuccess(concatAttributes);
    }, onerror);
}

/**
 * Groups the given features by value of given propertyNameToGroupBy, uses delimitor to split keys hidden in strings.
 * @param {ol/Feature[]} features A list of features to go through.
 * @param {String} propertyNameToGroupBy The property name to get the identifieres for the groups from.
 * @param {String} delimitor The delimitor, entities are separated with.
 * @returns {Object} An object with group keys and their corresponding features.
 */
function groupFeaturesByPropertyName (features, propertyNameToGroupBy, delimitor) {
    if (!Array.isArray(features)) {
        return {};
    }
    const result = {};

    features.forEach(feature => {
        if (typeof feature?.get !== "function") {
            return;
        }
        const attrName = feature.get(propertyNameToGroupBy),
            keys = attrName.split(delimitor),
            uniqueKeys = {};

        keys.forEach(key => {
            uniqueKeys[key] = true;
        });
        Object.keys(uniqueKeys).forEach(key => {
            if (!Array.isArray(result[key])) {
                result[key] = [];
            }
            result[key].push(feature);
        });
    });

    return result;
}

/**
 * Uses precompiler nextFeatureByDistance to receive the distance for the given features.
 * @param {Number[]} coordinate The coordinate to measure the distance for.
 * @param {ol/Feature[]} groupedFeatures A list of features to measure.
 * @param {String} knowledgeBaseKey The property name for the distance.
 * @param {String[]} propertyName All property names to included into the result.
 * @param {Function} onsuccess A function(groupedAttributes) with groupedAttributes as object with group keys and needed attributes as value.
 * @param {Function} onerror A function(error) with error as instanceof Error to call in case of an error.
 * @param {Object} [result={}] The result as object with group keys and needed attributes as value - to use for recursion.
 * @param {Number} [idx=0] The pointer to the current feature - to use for recursion.
 * @returns {void}
 */
function getGroupedAttributes (coordinate, groupedFeatures, knowledgeBaseKey, propertyName, onsuccess, onerror, result = {}, idx = 0) {
    if (!Array.isArray(coordinate) || !isObject(groupedFeatures)) {
        onsuccess({});
        return;
    }
    const key = Object.keys(groupedFeatures)[idx],
        features = groupedFeatures[key];

    if (!features) {
        onsuccess(result);
        return;
    }
    nextFeatureByDistance(coordinate, features, knowledgeBaseKey, propertyName, attributes => {
        result[key] = attributes;
        getGroupedAttributes(coordinate, groupedFeatures, knowledgeBaseKey, propertyName, onsuccess, onerror, result, idx + 1);
    }, onerror);
}

/**
 * Removes all parts of attribute value that are not part of its top group.
 * @param {Object} groupedAttributes An object with group keys and attributes generated by features - with entities that don't correspond with the group keys.
 * @param {String} propertyNameToGroupBy The property name to get the identifieres for the group from.
 * @param {String} delimitor The delimitor, entities are separated with.
 * @param {String} knowledgeBaseKey The property name for the distance - needs a different approach.
 * @returns {Object} An object with group keys and attributes, where every entity correspond with the group key.
 */
function purifyGroupedAttributes (groupedAttributes, propertyNameToGroupBy, delimitor, knowledgeBaseKey) {
    if (!isObject(groupedAttributes)) {
        return {};
    }
    const result = {};

    Object.entries(groupedAttributes).forEach(([groupKey, attributes]) => {
        const keys = attributes[propertyNameToGroupBy][0].split(delimitor),
            len = keys.length;

        result[groupKey] = {};
        for (let i = 0; i < len; i++) {
            if (keys[i] !== groupKey) {
                continue;
            }
            Object.entries(attributes).forEach(([attrName, arrayOfValue]) => {
                if (typeof result[groupKey][attrName] === "string") {
                    result[groupKey][attrName] += ", ";
                }
                else {
                    result[groupKey][attrName] = "";
                }
                if (attrName === knowledgeBaseKey) {
                    result[groupKey][attrName] = arrayOfValue[0];
                }
                else if (attrName === propertyNameToGroupBy) {
                    result[groupKey][attrName] = arrayOfValue[0].split(delimitor)[i];
                }
                else {
                    result[groupKey][attrName] += arrayOfValue[0].split(delimitor)[i];
                }
            });
        }
    });

    return result;
}

/**
 * Concats all attributes with focus on the attribute key.
 * This creates the finished object structure.
 * @param {Object} groupedAttributes An object to collect the attributes from.
 * @returns {Object} An object with attrNames as keys and values the concatenated attribute value.
 */
function concatGroupAttributes (groupedAttributes) {
    if (!isObject(groupedAttributes)) {
        return {};
    }
    const result = {};

    Object.values(groupedAttributes).forEach(attributes => {
        if (!isObject(attributes)) {
            return;
        }
        Object.entries(attributes).forEach(([key, value]) => {
            if (!Array.isArray(result[key])) {
                result[key] = [];
            }
            result[key].push(value);
        });
    });

    return result;
}

export {
    nextGroupedFeaturesByDistance,
    groupFeaturesByPropertyName,
    getGroupedAttributes,
    purifyGroupedAttributes,
    concatGroupAttributes
};
